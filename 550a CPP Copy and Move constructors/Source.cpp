// 550 CPP Copy and Move constructors
//
// Examples of copy and move constructors
// http://stackoverflow.com/questions/5481539/what-does-t-double-ampersand-mean-in-c11/5481588#5481588
// https://blogs.msdn.microsoft.com/vcblog/2009/02/03/rvalue-references-c0x-features-in-vc10-part-2/
// http://www.cplusplus.com/doc/tutorial/classes2/
//
// From http://stackoverflow.com/questions/3734247/what-are-all-the-member-functions-created-by-compiler-for-a-class-does-that-hap
// C++98/03
// If they are needed,
// . the compiler will generate a default constructor for you unless you declare any constructor of your own.
// . the compiler will generate a copy constructor for you unless you declare your own.
// . the compiler will generate a copy assignment operator for you unless you declare your own.
// .  the compiler will generate a destructor for you unless you declare your own.
// All those are only generated by the compiler when they are needed. (The difference is that, when the compiler cannot create them, that's Ok as long as they aren't used.)
// 
// C++11
// C++11 adds the following rules, which are also true for C++14:
// The compiler generates the move constructor if
// . there is no user-declared copy constructor, and
// . there is no user-declared copy assignment operator, and
// . there is no user-declared move assignment operator and
// . there is no user-declared destructor,
// . it is not marked as deleted,
// . and all members and bases are moveable.
// Similar for the move assignment operator: It is generated if
// . there is no user defined
// . there is no user-declared copy constructor, and
// . there is no user-declared copy assignment operator, and
// . there is no user-declared move constructor and
// . there is no user-declared destructor,
// . it is not marked as deleted,
// . and all members and bases are moveable.
// 
// For an easier understanding of what is what of the above here the items for Thing:
// class Thing {
// public:
//   Thing();                        // default constructor
//   Thing(const Thing&);            // copy c'tor
//   Thing& operator=(const Thing&); // copy-assign
//   ~Thing();                       // d'tor
// // C++11:
//   Thing(Thing&&);                 // move c'tor
//   Thing& operator=(Thing&&);      // move-assign
// };

// From https://rmf.io/cxx11/rule-of-zero
// Rule of Three: If a class defines a destructor, copy constructor or copy assignment operator then it should probably 
// explicitly define all three, and not rely on their default implementation.
// Rule of Zero (which is actually a particular instance of the Single Responsibility Principle):
// Classes that have custom destructors, copy/move constructors or copy/move assignment operators should deal exclusively 
// with ownership. Other classes should not have custom destructors, copy/move constructors or copy/move assignment operators.

// 2016-10-02	PV
// 2016-10-11	PV		Complete class T with six special member functions and purr/meow examples
// 2017-01-22	PV		More comments; Restored toolset 140 (has switcher to toolset 141 after install of Visual Studio 2017 RC preventing build)
// 2017-04-29	PV		GitHub and Linux


#define _SCL_SECURE_NO_WARNINGS		// Otherwise use of copy generated a deprecated error

#include <stdio.h>
#include <string>
#include <sstream>
#include <iostream>

using namespace std;

class T
{
private:
	int  length;
	int* ptr;

public:
	// Default constructor
	T()
	{
		cout << "T Default constructor\n";
		this->length = 0;
		ptr = nullptr;
	}

	// Unary constructor
	T(int length)
	{
		cout << "T Unary constructor\n";
		ptr = new int[length];
		// Actually, raises an exception and does not return null...
		if (ptr)
		{
			this->length = length;
			for (int i = 0; i < length; i++)
				ptr[i] = i + 10;
		}
		else
		{
			cout << "*** Memory allocation failed\n";
			this->length = 0;
		}
	}

	// Copy constructor
	T(T const& other)
	{
		cout << "T Copy constructor\n";
		this->length = other.length;
		ptr = new int[other.length];
		if (ptr)
		{
			copy(other.ptr, other.ptr + other.length, this->ptr);
		}
		else
		{
			cout << "*** Memory allocation failed\n";
			this->length = 0;
		}
	}

	// Move constructor
	T(T&& other)
	{
		cout << "T Move constructor\n";
		//__debugbreak();
		this->length = other.length;
		this->ptr = other.ptr;
		other.length = 0;
		other.ptr = nullptr;
	}

	// Destructor
	~T()
	{
		cout << "T Destructor\n";
		delete[] ptr;
	}

	// Copy assignment
	T& operator=(const T& other)
	{
		cout << "T Copy assignment operator\n";
		if (this != &other)
		{
			delete[] ptr;
			length = other.length;
			if (length == 0)
			{
				ptr = nullptr;
			}
			else
			{
				ptr = new int[length];
				if (ptr)
					copy(other.ptr, other.ptr + other.length, ptr);
				else
				{
					cout << "*** Memory allocation failed\n";
					length = 0;
				}
			}
		}
		return *this;
	}

	// Move assignment
	T& operator=(T&& other)
	{
		cout << "T Move assignment operator\n";
		if (this != &other)
		{
			delete[] ptr;
			length = other.length;
			ptr = other.ptr;
			other.ptr = nullptr;
		}
		return *this;
	}

	string ToString()
	{
		stringstream ss;
		for (int i = 0; i < length; i++)
		{
			if (i == 0)
				ss << "{";
			else
				ss << ", ";
			ss << ptr[i];
		}
		ss << "}";
		return ss.str();
	}

	int GetLength() 
	{
		return length;
	}

};


class U
{
private:
	T t1;
	T t2;

public:
	U() {
		cout << "U Default constructor\n";
	}

	U(int n) : t1(T(n)), t2(T(n)) {
		cout << "U Unary constructor\n";
	}

	~U()
	{
		cout << "U Destructor\n";
	}

	U(const U& other) {
		cout << "U Copy constructor\n";
			t1 = other.t1;
			t2 = other.t2;
	}

	U(U&& other) {
		cout << "U Move constructor\n";
		if (this != &other)
		{
			t1 = move(other.t1);	// Move needed, since other.t1 is a lvalue
			t2 = move(other.t2);
		}
	}

	U& operator=(const U& other) {
		cout << "U Copy assignment operator\n";
		if (this != &other) {
			t1 = other.t1;
			t2 = other.t2;
		}
		return *this;
	}

	//U& operator=(U&& other) = default;		// Correctly calls T move assignment operator

	U& operator=(U&& other) {
		cout << "U Move assignment operator\n";
		if (this != &other) {
			t1 = move(other.t1);	// Without move, no way it knows it has to call move
			t2 = move(other.t2);	// assignment operator and calls copy assignment operator
		}
		return *this;
	}

};

U GetU() {
	return U(2);
}

void meow(string &s) { cout << "meow(string&): " << s << endl; }
void meow(const string &s) { cout << "meow(const string&): " << s << endl; }
void meow(string &&s) { cout << "meow(string&&): " << s << endl; }
void meow(const string &&s) { cout << "meow(const string&&): " << s << endl; }

string strange() { return "strange()"; }
const string charm() { return "charm()"; }

void purr(const string &s) { cout << "purr(const string&): " << s << endl; }
void purr(string &&s) { cout << "purr(string&&): " << s << endl; }

//	Summary:
//	MyClass fn();           // function returning a MyClass object
//	MyClass foo;            // default constructor
//	MyClass barr(foo);      // copy constructor
//	MyClass bar = foo;      // copy constructor (not assignment!)
//	MyClass baz = fn();     // move constructor
//	foo = bar;              // copy assignment
//	baz = MyClass();        // move assignment 


class AutoDefault
{
public:
	T t = T{};				// Just to get some data

	// c'tor/d'tor
	AutoDefault() = default;
	~AutoDefault() = default;

	// copy operations
	AutoDefault(const AutoDefault&) = default;
	AutoDefault& operator=(const AutoDefault&) = default;

	// move operations
	AutoDefault(AutoDefault&&) = default;
	AutoDefault& operator=(AutoDefault&&) = default;
};


int main() {
	T r(3);			// unary constructor

	T s = T(r);		// copy constructor
	cout << s.ToString() << endl;
	s = r;			// copy assignment operator
	cout << s.ToString() << endl;
	s = T(r);		// move operator
	cout << s.ToString() << endl;

	T t = r;	// std::move(r);		// move, explicit, r is emptied
	cout << t.ToString() << endl;
	cout << r.GetLength() << endl;

	T tt = T(T(3));			// move, implicit for a temp
	cout << tt.ToString() << endl;
	cout << "--------------------------------" << endl;

	U u;
	cout << endl;
	u = GetU();
	cout << endl;
	U v = U(GetU());

	cout << "--------------------------------" << endl;

	string up("up");
	const string down("down");

	// 4 binding possibilities
	meow(up);
	meow(down);
	meow(strange());
	meow(charm());

	cout << endl;

	// 2 bindings possibilities
	purr(up);
	purr(down);
	purr(strange());
	purr(charm());

	cout << "--------------------------------" << endl;

	// Test of AutoDefault

	AutoDefault fn();           // Forward declare a function returning an AutoDefault object

	AutoDefault foo;            // default constructor
	AutoDefault barr(foo);      // copy constructor
	AutoDefault bar = foo;      // copy constructor (not assignment!)
	AutoDefault baz = fn();     // move constructor
	foo = bar;					// copy assignment
	baz = AutoDefault();        // move assignment 


#ifdef _WIN32
	cout << "\n(Pause)";
	cin.get();
#endif

	return 0;
}


AutoDefault fn()
{
	return AutoDefault{};
}
